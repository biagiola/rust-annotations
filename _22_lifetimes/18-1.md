# Multiple Lifetime Parameters

When single lifetime parameters aren't enough, we need multiple lifetime annotations to tell the borrow checker exactly which input lifetime the return value should follow.

## The Problem: When Single Lifetimes Fail (17.rs)

Here's a scenario where single lifetime annotation causes compilation errors:

```rust
fn longest<'a>(first: &'a str, second: &'a str) -> &'a str {
    if first.len() > second.len() {
        first
    } else {
        second
    }
}

fn main() {
    let orlando = String::from("Orlando");
    
    let result = {
        let san_francisco = String::from("San Francisco");
        longest(&orlando, &san_francisco) // ‚ùå ERROR: borrowed value does not live long enough
        // here we have a possibility of dangling reference coz, we can return
        // san_francisco to set into the result variable, but we can delete that one
        // when we finish this scope. Result has the potential of hold a dangling
        // reference.
    };
}
```

**Why this fails:** The single `'a` forces the borrow checker to assume `result` might point to `san_francisco`, which gets dropped when the block ends.

## The Solution: Multiple Lifetimes (18.rs)

We can fix this by using multiple lifetime parameters and being explicit about which parameter we return:

```rust
fn longest<'a, 'b>(first: &'a str, second: &'b str) -> &'a str {
    println!("{second}"); // Lifetime doesn't affect the params at runtime, so we can keep using it,
    first // but now we're telling with 'a that we should return `first`

    // We're saying to the borrow checker now that 'b doesn't matter for the
    // sake of persistence. All Rust needs to guarantee is that the referent‚Äî
    // the `result` variable, where the param `first` is coming from‚Äîis where the return
    // reference (`first`) is going to live within.
    // So the borrow checker understands that `result` will be a reference to, effectively,
    // `orlando` and not `san_francisco`. That's all said in the function `longest`'s
    // signature, and the borrow checker knows it.
}

fn main() {
    let orlando = String::from("Orlando");
    
    let result: &str = {
        let san_francisco = String::from("San Francisco");
        longest(&orlando, &san_francisco) // ‚úÖ Now this works!
    };
    // result points to orlando, which is still alive
}
```

**Why this works:** By using `&'a str` for the return type, we explicitly tell the compiler that the return value has the same lifetime as the **first** parameter only, not the second.

## When to use multiple lifetimes (`'a`, `'b`)

Use multiple lifetimes when you need to **distinguish** between different input lifetimes, usually because:

### 1. You always return from a specific parameter:
```rust
fn first<'a, 'b>(x: &'a str, y: &'b str) -> &'a str { 
    x  // Always return the first parameter
}
```

### 2. You need different lifetime guarantees:
```rust
fn store_reference<'long, 'short>(
    permanent: &'long str, 
    temporary: &'short str
) -> &'long str {
    // Only return the long-lived reference
    permanent
}
```


## Summary

**Multiple lifetime parameters are needed when:**
- You need to return a reference from a specific parameter, not just any parameter
- Single lifetime annotations are too restrictive for your use case
- You want to tell the borrow checker exactly which input lifetime the return follows

**Key concepts:**
- **Single `'a`**: Conservative, picks shortest lifetime, return could be from any input
- **Multiple lifetimes (`'a`, `'b`)**: Explicit, tells compiler exactly which input lifetime the return follows

**The progression:**
1. **17.rs**: Shows where single lifetimes fail (compilation error)
2. **18.rs**: Shows how multiple lifetimes solve the problem

Multiple lifetime parameters give you precision and control when single lifetimes are too restrictive! üéØ