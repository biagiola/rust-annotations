# Lifetime Elision Rules

The Rust compiler uses lifetime elision rules as a convenience to automatically infer and apply lifetime annotations to function signatures, allowing developers to write cleaner, less verbose code. These rules are not magical; they are a set of specific, predictable patterns that the compiler follows. If your function signature doesn't fit these rules, you must manually add the lifetime annotations.

Here is a summary of the three main elision rules:

## Rule 1: Each reference parameter gets its own lifetime parameter

If a function has one or more reference parameters, each one is assigned a unique lifetime. For example:
- A function `fn foo(x: &T)` is treated as `fn foo<'a>(x: &'a T)`
- A function `fn bar(x: &T, y: &U)` is treated as `fn bar<'a, 'b>(x: &'a T, y: &'b U)`

## Rule 2: Single input lifetime assigned to all outputs

If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters.

This is the most common and intuitive rule. If a function takes a single reference and returns a single reference, the output reference is assumed to have the same lifetime as the input.

For example,
- A function  `fn first_word(s: &str) -> &str`
- It's treated as `fn first_word<'a>(s: &'a str) -> &'a str`.

## Rule 3: Methods with `&self` or `&mut self`

If there are multiple input lifetime parameters, but one of them is `&self` or `&mut self`, the lifetime of `self` is assigned to all output lifetime parameters.

This rule is specifically for methods on structs (methods with `&self` or `&mut self`). The compiler assumes that if a method returns a reference, that reference's lifetime is tied to the lifetime of the struct itself.

For example,
- A method `fn get_name(&self, s: &str) -> &str`
- It's treated as `fn get_name<'a>(&'a self, s: &str) -> &'a str`.

The lifetime of `s` is elided because it's not needed for the return type.
